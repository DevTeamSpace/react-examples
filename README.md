Так как в проекте используется сочетание react+redux, то есть две основных сущности отвечающих за визуальное отображение, компоненты и контейнеры.
Компоненты представляют из себя разметку, когда основная логика и состояние приложения передает контейнер в компоненты внутри его.

# Компонент Comments.js

Данный компонент представляет из себя комментарий к запросу пользователя. Основной особенностью комментария в данном проекте является наличие быстрой карточки пользователя - подключаемый модуль Avatar.
Так как быстрая карточка пользователя содержит в себе много информации, соответственно мы должны ее передать в данный компонент. Для этого параметры предварительно формируется prepareAvatarData(item) {}.
Компоненты формируются таким образом, чтоб избежать огромной логики внутри и чтобы можно было повторно ипользовать компонент в разных местах приложения.
В самом верху объявления компонента производится проверка входящих параметров. Это очень облегчает разработку, а такая запись позволяет быстрей понять что должен получить компонент на вход.

# Компонент ChatMenu

Данный компонент используется для построения списка чатов, на странице чатов.
В этом списке могут содержаться разные элементы
-чат. Представляет из себя подключаемый компонент SearchListChat который содержит в себе информацию о пользователе, его аватар, время последнего посещения, а так же последнее сообщение с данным пользователем. По нажатию происходит переход к чату с данным пользователем
-пользователь. Отображаеся только после получения результатов глобального поиска по юзерам. Содержит в себе информацию о пользователе и его аватар. По нажатию происходит создание чата с данным пользователем

Так же в компоненте присутствует строка поиска. Поиск происходит диспатчем события this.props.dispatch(searchChat(text, chats)) в которое передаются необходимые параметры. Но так как поиск выполняется еще и на сервере, было принято решение использовать debounce в 500мс на поиск.  Список чатов хранится локально поэтому фильтация имеющихся чатов происходит сразу локально в редьюсере.
При пустом списке чатов существует заглушка которая информирует о возможности использовать поиск.
Для улучшения вида приложения используется нестандартный скроллбар из модуля react-custom-scrollbars с параметрами для автоскрытия и скрытием горизонтального скролла (для windows OS)
В проекте используется redux поэтому подход к построению компонентов таков что компонент должен содержать разметку, а за его состояние должен отвечать контейнер. Но есть такие моменты для которых все же лучше использовать изменение состояния внутри компонента. Таким примером служит создание контроллируемого текстбокса, где его значение зависит от состояния.

# Компонент ChatCard

Данный компонент используется для вывода сообщений с пользователем, на странице чатов.
Компонент выводит список сообщений с пользователем, где сообщения представляют из себя массив объектов с полями: текст, время отправки, автор сообщения, статус сообщений (отправляется/отправлено/не отправлено).
Так же как и в ChatMenu используется кастомный скроллбар с параметрами и автопрокруткой в конец при изменении параметров (получение сообщения/отправка сообщения).
Отправка сообщений производится диспатчем события с параметрами this.props.dispatch(sendMessage(this.state.message, this.props.user.user_id));.
В текстовом поле для ввода сообщений имеется счетчик количества символов который ограничевает ввод текста превыше допустимого. Ограничение основывается на проверке и установке состояния в компоненте.
Так же в компоненте предусмотрена возможность добавлять пользователя в друзья или группы. Для этого используется созданный нами компонент PersonDropdown.
Имя пользователя отображаемое в данном компоненте является ссылкой на страницу пользователя, а именно <Link> из react-router. Ссылка формируется при помощи ES6 интерполяции строк {`/people/${user.user_id}`}

# sagas.js

В проекте используется sagas. Это новый подход при работе с react+redux.
sagas используют для формирования и отправки запросов на сервер. В стандартном подходе redux это происходило в actions. Использование sagas дает ряд приемуществ.
-Actions теперь не несут дополнительной логики, а только отвечают за тип события и его параметры.
В sagas имеются функции, и для каждой из них есть свой отдельный watcher который реагирует на заданое событие.
В данной саге формируются и отправляются запросы для работы со страницей чатов, после чего диспатчится новое событие, но уже с данными которые вернул нам сервер. Для большего удобства используется модуль normalizer, который из массива объектов создает один объект упорядоченный по уникальному полю.